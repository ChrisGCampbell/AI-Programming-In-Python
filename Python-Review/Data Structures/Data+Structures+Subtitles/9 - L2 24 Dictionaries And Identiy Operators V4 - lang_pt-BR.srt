1
00:00:00,558 --> 00:00:01,916
ESTRUTURAS DE DADOS

2
00:00:01,949 --> 00:00:03,920
DICIONÁRIOS
E OPERADORES DE IDENTIDADE

3
00:00:04,490 --> 00:00:06,775
Os conjuntos são estruturas
simples de dados

4
00:00:06,808 --> 00:00:10,358
e têm um uso principal:
coletar elementos únicos.

5
00:00:10,391 --> 00:00:14,661
A próxima estrutura de dados -
o dicionário - é mais flexível.

6
00:00:14,694 --> 00:00:16,725
Em vez de armazenar
objetos únicos -

7
00:00:16,758 --> 00:00:18,799
como as listas
e os conjuntos fazem -,

8
00:00:18,832 --> 00:00:21,293
os dicionários armazenam
pares de elementos,

9
00:00:21,326 --> 00:00:23,453
chaves e valores.

10
00:00:23,486 --> 00:00:25,945
Neste exemplo,
definimos um dicionário,

11
00:00:25,978 --> 00:00:28,268
no qual as chaves
são os nomes dos elementos

12
00:00:28,301 --> 00:00:31,651
e os valores,
os números atômicos correspondentes.

13
00:00:31,684 --> 00:00:33,923
Podemos procurar valores
em um dicionário

14
00:00:33,956 --> 00:00:37,107
usando colchetes
para fechar uma chave.

15
00:00:37,140 --> 00:00:40,091
Também podemos inserir
novos valores ao dicionário

16
00:00:40,124 --> 00:00:41,715
com colchetes.

17
00:00:41,748 --> 00:00:45,989
Aqui adicionamos o lítio
e atribuímos o valor 3.

18
00:00:46,022 --> 00:00:49,105
As chaves do dicionário
parecem os índices das listas.

19
00:00:49,138 --> 00:00:51,653
Selecionamos elementos
de uma estrutura de dados

20
00:00:51,686 --> 00:00:54,316
colocando a chave
entre colchetes.

21
00:00:54,349 --> 00:00:55,709
Diferente das listas,

22
00:00:55,742 --> 00:00:58,830
os dicionários podem ter chaves
de qualquer tipo imutável,

23
00:00:58,863 --> 00:01:00,477
não só de inteiros.

24
00:01:00,510 --> 00:01:04,261
O dicionário do elemento
usa strings para as chaves.

25
00:01:04,294 --> 00:01:06,964
Porém, não é necessário
que toda chave

26
00:01:06,997 --> 00:01:08,677
tenha o mesmo tipo.

27
00:01:09,349 --> 00:01:12,315
Podemos conferir se um valor
está no dicionário

28
00:01:12,348 --> 00:01:15,777
assim como checamos se um valor
está na lista ou no conjunto,

29
00:01:15,810 --> 00:01:17,579
com a palavra-chave "in".

30
00:01:17,612 --> 00:01:21,353
Podemos usar "in" para verificar
se uma chave está no dicionário

31
00:01:21,386 --> 00:01:23,033
antes de procurá-la,

32
00:01:23,066 --> 00:01:26,241
caso haja a possibilidade
de a chave não estar lá.

33
00:01:26,274 --> 00:01:29,217
"Mithril" não fazia parte
do dicionário de elementos,

34
00:01:29,250 --> 00:01:31,442
então False foi impresso.

35
00:01:31,475 --> 00:01:35,050
Os dicionários têm um método
parecido que é muito útil,

36
00:01:35,083 --> 00:01:38,329
o get, que procura por valores
no dicionário.

37
00:01:38,362 --> 00:01:41,554
Mas, diferente dos colchetes,
ele retorna None

38
00:01:41,587 --> 00:01:43,698
ou um valor padrão
de sua escolha

39
00:01:43,731 --> 00:01:45,857
se a chave
não for encontrada.

40
00:01:45,890 --> 00:01:48,288
"Dilithium"
não está no dicionário,

41
00:01:48,321 --> 00:01:51,075
então None é retornado
e impresso.

42
00:01:51,108 --> 00:01:53,740
Se você espera que as buscas
falhem às vezes,

43
00:01:53,773 --> 00:01:57,163
o get pode ser uma escolha melhor
do que os colchetes,

44
00:01:57,196 --> 00:01:59,388
pois os erros podem travar
o programa,

45
00:01:59,421 --> 00:02:00,731
e isso não é bom.

46
00:02:00,764 --> 00:02:03,156
Podemos conferir se uma chave
retorna None

47
00:02:03,189 --> 00:02:04,698
com o operador is

48
00:02:04,731 --> 00:02:08,606
ou podemos conferir o contrário
usando o is not.

49
00:02:08,639 --> 00:02:11,349
Eles são chamados
de "operadores de identidade".

50
00:02:11,382 --> 00:02:14,034
Veremos mais sobre eles

51
00:02:14,067 --> 00:02:17,259
e como se diferem
dos operadores de comparação

52
00:02:17,292 --> 00:02:21,213
"igual a" e "não igual a"
nos quizzes a seguir.

